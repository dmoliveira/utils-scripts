#!/usr/bin/env bash

set -euo pipefail

PASS_COUNT=0
WARN_COUNT=0
FAIL_COUNT=0
STRICT_MODE=false
JSON_MODE=false

usage() {
  cat <<'EOF'
Usage: verify_post_install_unix [options]

Options:
  --strict    Treat warnings as failures
  --json      Print final summary as JSON only
  -h, --help  Show this help message
EOF
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --strict)
        STRICT_MODE=true
        ;;
      --json)
        JSON_MODE=true
        ;;
      -h | --help)
        usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1" >&2
        usage >&2
        exit 1
        ;;
    esac
    shift
  done
}

say() {
  if [[ "$JSON_MODE" == "false" ]]; then
    printf '%s\n' "$1"
  fi
}

pass() {
  PASS_COUNT=$((PASS_COUNT + 1))
  say "PASS: $1"
}

warn() {
  if [[ "$STRICT_MODE" == "true" ]]; then
    fail "$1"
    return
  fi
  WARN_COUNT=$((WARN_COUNT + 1))
  say "WARN: $1"
}

fail() {
  FAIL_COUNT=$((FAIL_COUNT + 1))
  say "FAIL: $1"
}

check_command() {
  local cmd="$1"
  if command -v "$cmd" >/dev/null 2>&1; then
    pass "command '$cmd' available"
  else
    fail "command '$cmd' missing"
  fi
}

check_optional_command() {
  local cmd="$1"
  local label="${2:-command '$1' available}"
  local missing_label="${3:-command '$1' missing (optional)}"

  if command -v "$cmd" >/dev/null 2>&1; then
    pass "$label"
  else
    warn "$missing_label"
  fi
}

check_file() {
  local file="$1"
  if [[ -f "$file" ]]; then
    pass "file '$file' exists"
  else
    fail "file '$file' missing"
  fi
}

run_check() {
  local label="$1"
  shift

  if "$@" >/dev/null 2>&1; then
    pass "$label"
  else
    fail "$label"
  fi
}

print_summary() {
  local status="ok"
  if [[ "$FAIL_COUNT" -gt 0 ]]; then
    status="failed"
  fi

  if [[ "$JSON_MODE" == "true" ]]; then
    printf '{"status":"%s","strict":%s,"pass":%d,"warn":%d,"fail":%d}\n' \
      "$status" "$STRICT_MODE" "$PASS_COUNT" "$WARN_COUNT" "$FAIL_COUNT"
    return
  fi

  echo
  echo "==> Summary"
  printf 'PASS: %s\n' "$PASS_COUNT"
  printf 'WARN: %s\n' "$WARN_COUNT"
  printf 'FAIL: %s\n' "$FAIL_COUNT"
}

parse_args "$@"

say "==> Checking required commands"
check_command zsh
check_command tmux
check_command nvim
check_command git
check_command fzf
check_command zoxide
check_command starship
check_command direnv
check_command atuin
check_command btop

say "==> Checking required config files"
check_file "$HOME/.zshrc"
check_file "$HOME/.tmux.conf"
check_file "$HOME/.config/nvim/init.lua"

say "==> Running syntax and startup checks"
run_check "zsh config syntax" zsh -n "$HOME/.zshrc"
run_check "tmux config parse" tmux -L utils-scripts-smoke -f "$HOME/.tmux.conf" new-session -d -s smoke
tmux -L utils-scripts-smoke kill-server >/dev/null 2>&1 || true
if command -v lua >/dev/null 2>&1; then
  run_check "nvim init.lua syntax" lua -e "assert(loadfile('$HOME/.config/nvim/init.lua'))"
else
  warn "command 'lua' missing; skipping standalone init.lua syntax parse"
fi
run_check "neovim headless start" nvim --headless +qa

say "==> Checking monitoring tools"
if [[ "$(uname -s)" == "Darwin" ]]; then
  check_command btm
  if [[ "$(uname -m)" == "arm64" ]]; then
    if command -v asitop >/dev/null 2>&1; then
      pass "command 'asitop' available (Apple Silicon)"
    else
      warn "command 'asitop' missing (optional on Apple Silicon)"
    fi
  fi
else
  if command -v nvidia-smi >/dev/null 2>&1 || [[ -e "/dev/dri" ]]; then
    if command -v nvtop >/dev/null 2>&1; then
      pass "command 'nvtop' available (GPU detected)"
    else
      warn "command 'nvtop' missing while GPU detected"
    fi
  else
    pass "nvtop skipped (no GPU detected)"
  fi
fi

say "==> Checking advanced productivity tools"
check_optional_command lazygit "command 'lazygit' available"
check_optional_command hyperfine "command 'hyperfine' available"
check_optional_command dua "command 'dua' available"
check_optional_command dust "command 'dust' available"
check_optional_command procs "command 'procs' available"
check_optional_command xh "command 'xh' available"
check_optional_command doggo "command 'doggo' available"
check_optional_command watchexec "command 'watchexec' available"
check_optional_command kubectl "command 'kubectl' available"
check_optional_command k9s "command 'k9s' available"
check_optional_command trivy "command 'trivy' available"
check_optional_command zellij "command 'zellij' available"

if [[ "$(uname -s)" == "Darwin" ]]; then
  say "==> Checking Ghostty on macOS"
  if [[ -x "/Applications/Ghostty.app/Contents/MacOS/ghostty" ]]; then
    pass "Ghostty app binary exists"
    if [[ -f "$HOME/.config/ghostty/config" ]]; then
      if "/Applications/Ghostty.app/Contents/MacOS/ghostty" +validate-config --config-file "$HOME/.config/ghostty/config" >/dev/null 2>&1; then
        pass "Ghostty config validates"
      else
        warn "Ghostty config validation failed"
      fi
    else
      warn "Ghostty config not found at $HOME/.config/ghostty/config"
    fi
  else
    warn "Ghostty app not found at /Applications/Ghostty.app"
  fi
fi

print_summary

if [[ "$FAIL_COUNT" -gt 0 ]]; then
  exit 1
fi

say "Smoke test completed successfully."
