# -- EC-Start ---------------------------------
# Enhanced Custom '.zshrc'
# ---------------------------------------------

# ─────────────────────────────────────────────
# Locale & Environment
# ─────────────────────────────────────────────
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8
export TERM="${TERM:-xterm-256color}"

# ─────────────────────────────────────────────
# Paths
# ─────────────────────────────────────────────
export PATH="$HOME/bin:/usr/local/bin:$PATH"

# ─────────────────────────────────────────────
# Default Editor
# ─────────────────────────────────────────────
export EDITOR="vim"

# ─────────────────────────────────────────────
# Colors & Options
# ─────────────────────────────────────────────
export CLICOLOR=1
export LSCOLORS=GxFxCxDxBxegedabagaced
setopt AUTO_CD                 # cd just by typing dir
setopt HIST_IGNORE_ALL_DUPS
setopt SHARE_HISTORY
setopt AUTO_PUSHD PUSHD_IGNORE_DUPS

# ─────────────────────────────────────────────
# History
# ─────────────────────────────────────────────
HISTFILE=~/.zsh_history
HISTSIZE=20000
SAVEHIST=20000

# ─────────────────────────────────────────────
# Plugin Manager: Zinit (lazy loads plugins)
# ─────────────────────────────────────────────
if [[ ! -f ~/.zinit/bin/zinit.zsh ]]; then
  mkdir -p ~/.zinit/bin
  git clone https://github.com/zdharma-continuum/zinit.git ~/.zinit/bin
fi
source ~/.zinit/bin/zinit.zsh

# ─────────────────────────────────────────────
# Plugins
# ─────────────────────────────────────────────
zinit light zsh-users/zsh-autosuggestions
zinit light zsh-users/zsh-syntax-highlighting
zinit light zsh-users/zsh-completions
zinit light zsh-users/zsh-history-substring-search
zinit light Aloxaf/fzf-tab

# fzf & zoxide
if command -v fzf >/dev/null 2>&1; then
  [ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
fi
if command -v zoxide >/dev/null 2>&1; then
  eval "$(zoxide init zsh)"
fi
if command -v direnv >/dev/null 2>&1; then
  eval "$(direnv hook zsh)"
fi
if command -v atuin >/dev/null 2>&1; then
  eval "$(atuin init zsh)"
fi

_load_shell_secrets() {
  local secrets_file="${XDG_CONFIG_HOME:-$HOME/.config}/secrets/shell.env"
  local perms=""

  if [[ ! -f "$secrets_file" ]]; then
    return
  fi

  if perms=$(stat -f "%OLp" "$secrets_file" 2>/dev/null); then
    if [[ "$perms" != "600" && "$perms" != "400" ]]; then
      echo "Skipping $secrets_file: require chmod 600 or 400"
      return
    fi
  elif perms=$(stat -c "%a" "$secrets_file" 2>/dev/null); then
    if [[ "$perms" != "600" && "$perms" != "400" ]]; then
      echo "Skipping $secrets_file: require chmod 600 or 400"
      return
    fi
  fi

  source "$secrets_file"
}

_load_shell_secrets

if [[ -n "${terminfo[kcuu1]-}" ]]; then
  bindkey "${terminfo[kcuu1]}" history-substring-search-up
fi
if [[ -n "${terminfo[kcud1]-}" ]]; then
  bindkey "${terminfo[kcud1]}" history-substring-search-down
fi

# ─────────────────────────────────────────────
# Prompt: Starship
# ─────────────────────────────────────────────
if command -v starship >/dev/null 2>&1; then
  eval "$(starship init zsh)"
fi

# Adaptive command-duration formatter for Starship custom module.
typeset -g _adaptive_cmd_started_at=""

_adaptive_duration_format() {
  local total_ms=$1
  local day_ms=86400000
  local hour_ms=3600000
  local minute_ms=60000
  local second_ms=1000

  if (( total_ms >= day_ms )); then
    local d=$(( total_ms / day_ms ))
    local h=$(( (total_ms % day_ms) / hour_ms ))
    printf "%dd%dh" "$d" "$h"
    return
  fi

  if (( total_ms >= hour_ms )); then
    local h=$(( total_ms / hour_ms ))
    local m=$(( (total_ms % hour_ms) / minute_ms ))
    printf "%dh%dm" "$h" "$m"
    return
  fi

  if (( total_ms >= minute_ms )); then
    local m=$(( total_ms / minute_ms ))
    local s=$(( (total_ms % minute_ms) / second_ms ))
    printf "%dm%ds" "$m" "$s"
    return
  fi

  if (( total_ms >= second_ms )); then
    local s=$(( total_ms / second_ms ))
    local ms=$(( total_ms % second_ms ))
    printf "%ds%dms" "$s" "$ms"
    return
  fi

  printf "%dms" "$total_ms"
}

_adaptive_duration_preexec() {
  _adaptive_cmd_started_at="$EPOCHREALTIME"
}

_adaptive_duration_precmd() {
  if [[ -z "${_adaptive_cmd_started_at}" ]]; then
    export ADAPTIVE_CMD_DURATION=""
    return
  fi

  local started_at="$_adaptive_cmd_started_at"
  _adaptive_cmd_started_at=""

  local elapsed_ms=$(( (EPOCHREALTIME - started_at) * 1000 ))
  if (( elapsed_ms >= 2000 )); then
    export ADAPTIVE_CMD_DURATION="$(_adaptive_duration_format "$elapsed_ms")"
  else
    export ADAPTIVE_CMD_DURATION=""
  fi
}

autoload -Uz add-zsh-hook
add-zsh-hook preexec _adaptive_duration_preexec
add-zsh-hook precmd _adaptive_duration_precmd

# ─────────────────────────────────────────────
# WezTerm Git Status
# ─────────────────────────────────────────────
_wezterm_update_git_branch() {
  if [[ -z "${WEZTERM_PANE-}" ]]; then
    return
  fi

  if ! typeset -f __wezterm_set_user_var >/dev/null 2>&1; then
    return
  fi

  local branch=""
  if command git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    branch=$(command git symbolic-ref --short HEAD 2>/dev/null)
    if [[ -z "$branch" ]]; then
      branch=$(command git rev-parse --short HEAD 2>/dev/null)
    fi
  fi

  __wezterm_set_user_var WEZTERM_GIT_BRANCH "$branch"
}

if ! (( ${precmd_functions[(Ie)_wezterm_update_git_branch]} )); then
  precmd_functions+=(_wezterm_update_git_branch)
fi

# Keep completion cycling active after plugin initialization.
setopt AUTO_MENU
zstyle ':completion:*' menu select
bindkey '^I' menu-complete

# ─────────────────────────────────────────────
# Tmux Autostart (skip if already inside)
# ─────────────────────────────────────────────
#if [[ -z "$TMUX" ]] && [[ $- == *i* ]]; then
#  tmux attach -t main || tmux new -s main
#fi

# ─────────────────────────────────────────────
# Aliases
# ─────────────────────────────────────────────
alias ll='ls -lah --color=auto'
alias gs='git status'
alias gl='git log --oneline --graph --decorate'
alias tm='tmux new -A -s main'
alias vim='nvim'  # comment out if not using neovim
alias lg='lazygit'
alias hf='hyperfine'
alias dui='dua i'
alias ds='dust -d 3'
alias px='procs'
alias hget='xh GET'
alias dns='doggo'
alias k='kubectl'
alias kga='kubectl get all -A'
alias tfscan='trivy fs .'

tmux-research() {
  local session="research"

  if ! command -v tmux >/dev/null 2>&1; then
    echo "tmux not installed"
    return 1
  fi

  if tmux has-session -t "$session" 2>/dev/null; then
    tmux attach -t "$session"
    return
  fi

  tmux new-session -d -s "$session" -n editor -c "$PWD"
  tmux send-keys -t "$session:editor" "${EDITOR:-nvim} ." C-m

  tmux new-window -t "$session" -n git -c "$PWD"
  tmux send-keys -t "$session:git" "command -v lazygit >/dev/null 2>&1 && lazygit || git status" C-m

  tmux new-window -t "$session" -n benchmark -c "$PWD"
  tmux send-keys -t "$session:benchmark" "command -v hyperfine >/dev/null 2>&1 && hyperfine --warmup 1 'python -V'" C-m

  tmux new-window -t "$session" -n monitor -c "$PWD"
  tmux send-keys -t "$session:monitor" "command -v btop >/dev/null 2>&1 && btop || htop" C-m

  tmux select-window -t "$session:editor"
  tmux attach -t "$session"
}

tmux-delivery() {
  local session="delivery"

  if ! command -v tmux >/dev/null 2>&1; then
    echo "tmux not installed"
    return 1
  fi

  if tmux has-session -t "$session" 2>/dev/null; then
    tmux attach -t "$session"
    return
  fi

  tmux new-session -d -s "$session" -n editor -c "$PWD"
  tmux send-keys -t "$session:editor" "${EDITOR:-nvim} ." C-m

  tmux split-window -h -t "$session:editor" -c "$PWD"
  tmux send-keys -t "$session:editor.2" "command -v watchexec >/dev/null 2>&1 && watchexec -e py,sh,lua,md 'make verify' || make verify" C-m

  tmux new-window -t "$session" -n git -c "$PWD"
  tmux send-keys -t "$session:git" "command -v lazygit >/dev/null 2>&1 && lazygit || git status" C-m

  tmux new-window -t "$session" -n security -c "$PWD"
  tmux send-keys -t "$session:security" "command -v trivy >/dev/null 2>&1 && trivy fs . || echo 'trivy not installed'" C-m

  tmux select-window -t "$session:editor"
  tmux attach -t "$session"
}

tmux-incident() {
  local session="incident"

  if ! command -v tmux >/dev/null 2>&1; then
    echo "tmux not installed"
    return 1
  fi

  if tmux has-session -t "$session" 2>/dev/null; then
    tmux attach -t "$session"
    return
  fi

  tmux new-session -d -s "$session" -n monitor -c "$PWD"
  tmux send-keys -t "$session:monitor" "command -v btop >/dev/null 2>&1 && btop || htop" C-m

  tmux split-window -h -t "$session:monitor" -c "$PWD"
  tmux send-keys -t "$session:monitor.2" "command -v procs >/dev/null 2>&1 && procs --sortd cpu || ps aux" C-m

  tmux new-window -t "$session" -n k8s -c "$PWD"
  tmux send-keys -t "$session:k8s" "command -v k9s >/dev/null 2>&1 && k9s || kubectl get pods -A" C-m

  tmux new-window -t "$session" -n network -c "$PWD"
  tmux send-keys -t "$session:network" "command -v doggo >/dev/null 2>&1 && doggo github.com A || nslookup github.com" C-m

  tmux select-window -t "$session:monitor"
  tmux attach -t "$session"
}

leader-pack-help() {
  cat <<'EOF'
Terminal leader pack shortcuts:
  tmux-research    Research + benchmark + monitor layout
  tmux-delivery    Delivery + verify + security layout
  tmux-incident    Incident response + k8s + network layout

Useful aliases:
  lg, hf, dui, ds, px, hget, dns, k, kga, tfscan
EOF
}

ghostty-reload() {
  local ghostty_bin="/Applications/Ghostty.app/Contents/MacOS/ghostty"
  local ghostty_cfg="$HOME/.config/ghostty/config"

  if [[ ! -x "$ghostty_bin" ]]; then
    echo "Ghostty binary not found at $ghostty_bin"
    return 1
  fi

  if [[ ! -f "$ghostty_cfg" ]]; then
    echo "Ghostty config not found at $ghostty_cfg"
    return 1
  fi

  "$ghostty_bin" +validate-config --config-file "$ghostty_cfg" || return 1
  ${EDITOR:-nvim} "$ghostty_cfg"
}

# ─────────────────────────────────────────────
# Completion Init
# ─────────────────────────────────────────────
mkdir -p ~/.zfunc
fpath=(~/.zfunc $fpath)

if command -v codex >/dev/null 2>&1; then
  if [[ ! -f ~/.zfunc/_codex ]]; then
    codex completion zsh > ~/.zfunc/_codex
  fi
fi

if command -v az >/dev/null 2>&1; then
  if [[ ! -f ~/.zfunc/_az ]]; then
    az completion zsh > ~/.zfunc/_az
  elif [[ "$(command -v az)" -nt ~/.zfunc/_az ]]; then
    az completion zsh > ~/.zfunc/_az
  fi
fi

autoload -Uz compinit
if [[ -f ~/.zcompdump ]] && { [[ -f ~/.zfunc/_codex && ~/.zcompdump -ot ~/.zfunc/_codex ]] || [[ -f ~/.zfunc/_az && ~/.zcompdump -ot ~/.zfunc/_az ]]; }; then
  rm -f ~/.zcompdump*
fi
compinit

# -- EC-End -----------------------------------
